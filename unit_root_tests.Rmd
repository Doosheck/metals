---
title: "Unit Root Tests for Metals Price Series"
output: 
  html_document:
    self_contained: true
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
knitr::opts_knit$set(root.dir = getwd()) 

# Required packages
# urca: Most comprehensive and robust package for unit root tests
# tseries: Additional unit root tests
pkgs <- c("urca", "tseries", "dplyr", "knitr")
missing <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
if(length(missing)) install.packages(missing)
lapply(pkgs, library, character.only = TRUE)

cat("=== PACKAGE INFORMATION ===\n")
cat("Primary package: 'urca' - Unit Root and Cointegration Tests for Time Series Data\n")
cat("Developed by Bernhard Pfaff, widely used in econometrics research\n")
cat("Secondary package: 'tseries' - for additional ADF and PP tests\n\n")
```

```{r load-data}
# Load data
lithium = read.csv("data/ALL_lithium_prices_cubic_spline.csv")
nickel = read.csv("data/ALL_nickel_prices_cubic_spline.csv")
cobalt = read.csv("data/ALL_cobalt_prices_cubic_spline.csv")
copper = read.csv("data/ALL_copper_prices_cubic_spline.csv")

# Convert Date columns
lithium$Date <- as.Date(lithium$Date)
nickel$Date  <- as.Date(nickel$Date)
cobalt$Date  <- as.Date(cobalt$Date)
copper$Date  <- as.Date(copper$Date)

# Remove LISAME from lithium
lithium <- subset(lithium, select = -LISAME)

# Get price columns
lithium_prices <- lithium[, -1]
nickel_prices <- nickel[, -1]
cobalt_prices <- cobalt[, -1]
copper_prices <- copper[, -1]

cat("\n=== DATA LOADED ===\n")
cat("Lithium series:", ncol(lithium_prices), "\n")
cat("Nickel series:", ncol(nickel_prices), "\n")
cat("Cobalt series:", ncol(cobalt_prices), "\n")
cat("Copper series:", ncol(copper_prices), "\n\n")

# Calculate returns (percentage returns)
calculate_returns <- function(prices) {
  returns <- lapply(1:ncol(prices), function(i) {
    x <- prices[, i]
    x <- na.omit(x)
    ret <- diff(log(x)) * 100  # Log returns in percentage
    return(ret)
  })
  names(returns) <- colnames(prices)
  return(returns)
}

lithium_returns <- calculate_returns(lithium_prices)
nickel_returns <- calculate_returns(nickel_prices)
cobalt_returns <- calculate_returns(cobalt_prices)
copper_returns <- calculate_returns(copper_prices)

cat("\n=== RETURNS CALCULATED ===\n")
cat("Returns are calculated as: log(Price_t / Price_{t-1}) * 100\n")
cat("This gives percentage log returns\n")
cat("Lithium return series:", length(lithium_returns), "\n")
cat("Nickel return series:", length(nickel_returns), "\n")
cat("Cobalt return series:", length(cobalt_returns), "\n")
cat("Copper return series:", length(copper_returns), "\n\n")
```

```{r helper-functions}
# Helper function to interpret unit root test results
interpret_adf <- function(test_result, series_name) {
  cat("\n--- INTERPRETATION for", series_name, "---\n")
  
  test_stat <- as.numeric(test_result@teststat)[1]
  crit_vals <- test_result@cval
  
  cat("Test Statistic:", round(test_stat, 4), "\n")
  cat("Critical Values: 1%=", round(crit_vals[1], 4), 
      ", 5%=", round(crit_vals[2], 4), 
      ", 10%=", round(crit_vals[3], 4), "\n")
  
  if(test_stat < crit_vals[3]) {
    cat("RESULT: REJECT null hypothesis at 10% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else if(test_stat < crit_vals[2]) {
    cat("RESULT: REJECT null hypothesis at 5% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else if(test_stat < crit_vals[1]) {
    cat("RESULT: REJECT null hypothesis at 1% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
}

interpret_kpss <- function(test_result, series_name) {
  cat("\n--- INTERPRETATION for", series_name, "---\n")
  
  test_stat <- as.numeric(test_result@teststat)[1]
  crit_vals <- test_result@cval
  
  cat("Test Statistic:", round(test_stat, 4), "\n")
  cat("Critical Values: 10%=", round(crit_vals[1], 4), 
      ", 5%=", round(crit_vals[2], 4), 
      ", 2.5%=", round(crit_vals[3], 4),
      ", 1%=", round(crit_vals[4], 4), "\n")
  
  if(test_stat > crit_vals[4]) {
    cat("RESULT: REJECT null hypothesis at 1% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[3]) {
    cat("RESULT: REJECT null hypothesis at 2.5% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[2]) {
    cat("RESULT: REJECT null hypothesis at 5% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[1]) {
    cat("RESULT: REJECT null hypothesis at 10% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  }
}
```

# LITHIUM UNIT ROOT TESTS

```{r lithium-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    LITHIUM RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

lithium_results <- list()

for(i in 1:length(lithium_returns)) {
  series_name <- names(lithium_returns)[i]
  series_data <- lithium_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: LITHIUM -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. Augmented Dickey-Fuller (ADF) Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Lithium", series_name))
  
  # 2. Phillips-Perron (PP) Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Lithium", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n")
  cat("NOTE: This test has OPPOSITE hypotheses compared to ADF and PP tests!\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Lithium", series_name))
  
  # 4. DF-GLS Test (Elliott-Rothenberg-Stock)
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n")
  cat("NOTE: This is an improved version of ADF with better power\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Lithium", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # Store results
  lithium_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Lithium
lithium_summary_table <- data.frame(
  Series = names(lithium_results),
  ADF_Stat = sapply(lithium_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(lithium_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(lithium_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(lithium_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(lithium_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(lithium_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(lithium_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(lithium_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== LITHIUM UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(lithium_summary_table, 
      caption = "Lithium Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(lithium_summary_table$ADF_Stat, names.arg=lithium_summary_table$Series, 
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$PP_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$KPSS_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$DFGLS_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# NICKEL UNIT ROOT TESTS

```{r nickel-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    NICKEL RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

nickel_results <- list()

for(i in 1:length(nickel_returns)) {
  series_name <- names(nickel_returns)[i]
  series_data <- nickel_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: NICKEL -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Nickel", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Nickel", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Nickel", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Nickel", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  nickel_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Nickel
nickel_summary_table <- data.frame(
  Series = names(nickel_results),
  ADF_Stat = sapply(nickel_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(nickel_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(nickel_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(nickel_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(nickel_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(nickel_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(nickel_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(nickel_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== NICKEL UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(nickel_summary_table,
      caption = "Nickel Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(nickel_summary_table$ADF_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$PP_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$KPSS_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$DFGLS_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# COBALT UNIT ROOT TESTS

```{r cobalt-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    COBALT RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

cobalt_results <- list()

for(i in 1:length(cobalt_returns)) {
  series_name <- names(cobalt_returns)[i]
  series_data <- cobalt_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: COBALT -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Cobalt", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Cobalt", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Cobalt", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Cobalt", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  cobalt_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Cobalt
cobalt_summary_table <- data.frame(
  Series = names(cobalt_results),
  ADF_Stat = sapply(cobalt_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(cobalt_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(cobalt_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(cobalt_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(cobalt_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(cobalt_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(cobalt_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(cobalt_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== COBALT UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(cobalt_summary_table,
      caption = "Cobalt Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(cobalt_summary_table$ADF_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$PP_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$KPSS_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$DFGLS_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# COPPER UNIT ROOT TESTS

```{r copper-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    COPPER RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

copper_results <- list()

for(i in 1:length(copper_returns)) {
  series_name <- names(copper_returns)[i]
  series_data <- copper_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: COPPER -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Copper", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Copper", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Copper", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Copper", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  copper_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Copper
copper_summary_table <- data.frame(
  Series = names(copper_results),
  ADF_Stat = sapply(copper_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(copper_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(copper_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(copper_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(copper_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(copper_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(copper_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(copper_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== COPPER UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(copper_summary_table,
      caption = "Copper Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(copper_summary_table$ADF_Stat, names.arg=copper_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$PP_Stat, names.arg=copper_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$KPSS_Stat, names.arg=copper_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$DFGLS_Stat, names.arg=copper_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# SUMMARY

```{r summary}
cat("\n")
cat("================================================================================\n")
cat("                              TEST SUMMARY\n")
cat("================================================================================\n\n")

cat("UNIT ROOT TESTS PERFORMED:\n\n")

cat("1. AUGMENTED DICKEY-FULLER (ADF) TEST\n")
cat("   - Package: urca::ur.df()\n")
cat("   - Null Hypothesis: Series has a unit root (non-stationary)\n")
cat("   - Interpretation: Reject H0 = Series is stationary\n\n")

cat("2. PHILLIPS-PERRON (PP) TEST\n")
cat("   - Package: urca::ur.pp()\n")
cat("   - Null Hypothesis: Series has a unit root (non-stationary)\n")
cat("   - Interpretation: Reject H0 = Series is stationary\n")
cat("   - Note: Corrects for serial correlation without including lags\n\n")

cat("3. KPSS STATIONARITY TEST\n")
cat("   - Package: urca::ur.kpss()\n")
cat("   - Null Hypothesis: Series is stationary (OPPOSITE of ADF/PP)\n")
cat("   - Interpretation: Reject H0 = Series has a unit root\n")
cat("   - Note: Used as complementary test to ADF/PP\n\n")

cat("4. DF-GLS TEST (Elliott-Rothenberg-Stock)\n")
cat("   - Package: urca::ur.ers()\n")
cat("   - Null Hypothesis: Series has a unit root (non-stationary)\n")
cat("   - Interpretation: Reject H0 = Series is stationary\n")
cat("   - Note: More powerful than standard ADF test\n\n")

cat("================================================================================\n")
cat("ANALYSIS PERFORMED:\n")
cat("================================================================================\n\n")

cat("RETURN CALCULATION:\n")
cat("  -> Returns calculated as: log(Price_t / Price_{t-1}) * 100\n")
cat("  -> This gives percentage log returns\n")
cat("  -> Log returns are preferred for financial time series analysis\n\n")

cat("UNIT ROOT TESTS ON RETURNS:\n")
cat("  -> All tests performed on return series (not price levels)\n")
cat("  -> Returns are typically stationary (price levels typically are not)\n")
cat("  -> Stationary returns are appropriate for GARCH modeling\n\n")

cat("EXPECTED RESULTS:\n")
cat("  -> Returns should be STATIONARY (reject null in ADF/PP/DF-GLS)\n")
cat("  -> Returns should be STATIONARY (fail to reject null in KPSS)\n")
cat("  -> If returns are stationary, they can be used directly for GARCH models\n\n")

cat("RECOMMENDATION FOR GARCH MODELING:\n")
cat("  -> If return series is stationary: Use directly in GARCH models\n")
cat("  -> If return series has unit root (rare): Further differencing may be needed\n")
cat("  -> GARCH models are designed for stationary series with time-varying volatility\n\n")
```

# DCC-GARCH PAIRWISE MODELS

```{r dcc-garch-setup, message=FALSE, warning=FALSE}
cat("\n")
cat("================================================================================\n")
cat("              DCC-GARCH PAIRWISE MODEL FITTING\n")
cat("================================================================================\n\n")

# Install packages if needed
if (!require("rmgarch", quietly = TRUE)) install.packages("rmgarch")
if (!require("rugarch", quietly = TRUE)) install.packages("rugarch")
library(rmgarch)
library(rugarch)
library(knitr)

cat("Fitting best DCC-GARCH models for pairwise combinations within each metal\n")
cat("This will fit separate models for each pair of series\n\n")
```

```{r prepare-returns-matrices}
# Prepare return matrices
prepare_return_matrix <- function(returns_list, dates) {
  min_len <- min(sapply(returns_list, length))
  return_matrix <- matrix(NA, nrow = min_len, ncol = length(returns_list))
  colnames(return_matrix) <- names(returns_list)
  
  for(i in 1:length(returns_list)) {
    return_matrix[, i] <- returns_list[[i]][1:min_len]
  }
  
  return(return_matrix)
}

lithium_returns_mat <- prepare_return_matrix(lithium_returns, lithium$Date)
nickel_returns_mat <- prepare_return_matrix(nickel_returns, nickel$Date)
cobalt_returns_mat <- prepare_return_matrix(cobalt_returns, cobalt$Date)
copper_returns_mat <- prepare_return_matrix(copper_returns, copper$Date)
```

```{r dcc-lithium-pairs}
cat("\n")
cat("================================================================================\n")
cat("                   LITHIUM - PAIRWISE DCC-GARCH MODELS\n")
cat("================================================================================\n\n")

# Function to fit best DCC-GARCH for a pair
fit_dcc_pair <- function(data_mat, col1, col2, metal_name) {
  pair_data <- data_mat[, c(col1, col2)]
  pair_data <- na.omit(pair_data)
  
  cat(sprintf("\nFitting DCC-GARCH for %s: %s vs %s\n", metal_name, colnames(pair_data)[1], colnames(pair_data)[2]))
  
  # Univariate GARCH specification
  uspec <- ugarchspec(
    mean.model = list(armaOrder = c(1,1)),
    variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
    distribution.model = "norm"
  )
  
  # Multivariate DCC specification
  spec <- dccspec(
    uspec = multispec(replicate(2, uspec)),
    dccOrder = c(1,1),
    distribution = "mvnorm"
  )
  
  # Fit model
  tryCatch({
    fit <- dccfit(spec, data = pair_data)
    
    # Extract key results
    dcc_params <- coef(fit)
    aic_val <- infocriteria(fit)[1]
    bic_val <- infocriteria(fit)[2]
    
    # Get dynamic correlations
    dcor <- rcor(fit)
    avg_cor <- mean(dcor[1,2,], na.rm=TRUE)
    
    cat(sprintf("  AIC: %.4f, BIC: %.4f\n", aic_val, bic_val))
    cat(sprintf("  Average Dynamic Correlation: %.4f\n", avg_cor))
    
    return(list(
      fit = fit,
      pair = c(colnames(pair_data)[1], colnames(pair_data)[2]),
      aic = aic_val,
      bic = bic_val,
      avg_cor = avg_cor,
      dcc_alpha = dcc_params["[Joint]dcca1"],
      dcc_beta = dcc_params["[Joint]dccb1"]
    ))
  }, error = function(e) {
    cat(sprintf("  Error fitting model: %s\n", e$message))
    return(NULL)
  })
}

# Fit all pairwise combinations for Lithium
lithium_pairs <- list()
lithium_cols <- colnames(lithium_returns_mat)
n_lithium <- length(lithium_cols)

if(n_lithium >= 2) {
  pair_idx <- 1
  for(i in 1:(n_lithium-1)) {
    for(j in (i+1):n_lithium) {
      result <- fit_dcc_pair(lithium_returns_mat, i, j, "Lithium")
      if(!is.null(result)) {
        lithium_pairs[[pair_idx]] <- result
        pair_idx <- pair_idx + 1
      }
    }
  }
  
  # Summary table
  if(length(lithium_pairs) > 0) {
    lithium_summary_df <- data.frame(
      Pair = sapply(lithium_pairs, function(x) paste(x$pair[1], "-", x$pair[2])),
      AIC = sapply(lithium_pairs, function(x) x$aic),
      BIC = sapply(lithium_pairs, function(x) x$bic),
      Avg_Correlation = sapply(lithium_pairs, function(x) x$avg_cor),
      DCC_Alpha = sapply(lithium_pairs, function(x) as.numeric(x$dcc_alpha)),
      DCC_Beta = sapply(lithium_pairs, function(x) as.numeric(x$dcc_beta))
    )
    
    cat("\n\n=== LITHIUM PAIRWISE DCC-GARCH SUMMARY ===\n")
    kable(lithium_summary_df, digits = 4, 
          caption = "Lithium: Pairwise DCC-GARCH Model Results")
    
    # Visualization of fitted pairs
    cat("\n--- LITHIUM DCC-GARCH MODEL FITTING VISUALIZATION ---\n\n")
    
    # Create pair matrix to show which models were fitted
    pair_matrix <- matrix(0, nrow=n_lithium, ncol=n_lithium)
    rownames(pair_matrix) <- colnames(pair_matrix) <- lithium_cols
    
    for(pair in lithium_pairs) {
      i <- which(lithium_cols == pair$pair[1])
      j <- which(lithium_cols == pair$pair[2])
      pair_matrix[i, j] <- 1
      pair_matrix[j, i] <- 1
    }
    
    # Heatmap of fitted pairs
    par(mar=c(8,8,3,2))
    image(1:n_lithium, 1:n_lithium, pair_matrix,
          col=c("white", "steelblue"),
          xlab="", ylab="", main="Lithium: DCC-GARCH Pairs Fitted",
          axes=FALSE)
    axis(1, at=1:n_lithium, labels=lithium_cols, las=2, cex.axis=0.7)
    axis(2, at=1:n_lithium, labels=lithium_cols, las=2, cex.axis=0.7)
    abline(h=seq(0.5, n_lithium+0.5, 1), v=seq(0.5, n_lithium+0.5, 1), col="gray80")
    text(n_lithium/2, -1.5, "Blue = Model Fitted", xpd=TRUE, cex=0.9)
    
    # Bar plots of model metrics
    par(mfrow=c(2,2), mar=c(8,4,3,1))
    
    barplot(lithium_summary_df$AIC, names.arg=1:nrow(lithium_summary_df),
            col="coral", main="AIC by Pair", ylab="AIC", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(lithium_summary_df$Avg_Correlation, names.arg=1:nrow(lithium_summary_df),
            col="darkgreen", main="Average Dynamic Correlation", 
            ylab="Correlation", xlab="Pair Number",
            las=1, border=NA, ylim=c(-1, 1))
    abline(h=0, lty=2)
    
    barplot(lithium_summary_df$DCC_Alpha, names.arg=1:nrow(lithium_summary_df),
            col="purple", main="DCC Alpha (Short-run)", 
            ylab="Alpha", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(lithium_summary_df$DCC_Beta, names.arg=1:nrow(lithium_summary_df),
            col="orange", main="DCC Beta (Long-run)", 
            ylab="Beta", xlab="Pair Number",
            las=1, border=NA)
    
    par(mfrow=c(1,1), mar=c(5,4,4,2))
  }
}
```

```{r dcc-nickel-pairs}
cat("\n")
cat("================================================================================\n")
cat("                   NICKEL - PAIRWISE DCC-GARCH MODELS\n")
cat("================================================================================\n\n")

nickel_pairs <- list()
nickel_cols <- colnames(nickel_returns_mat)
n_nickel <- length(nickel_cols)

if(n_nickel >= 2) {
  pair_idx <- 1
  for(i in 1:(n_nickel-1)) {
    for(j in (i+1):n_nickel) {
      result <- fit_dcc_pair(nickel_returns_mat, i, j, "Nickel")
      if(!is.null(result)) {
        nickel_pairs[[pair_idx]] <- result
        pair_idx <- pair_idx + 1
      }
    }
  }
  
  if(length(nickel_pairs) > 0) {
    nickel_summary_df <- data.frame(
      Pair = sapply(nickel_pairs, function(x) paste(x$pair[1], "-", x$pair[2])),
      AIC = sapply(nickel_pairs, function(x) x$aic),
      BIC = sapply(nickel_pairs, function(x) x$bic),
      Avg_Correlation = sapply(nickel_pairs, function(x) x$avg_cor),
      DCC_Alpha = sapply(nickel_pairs, function(x) as.numeric(x$dcc_alpha)),
      DCC_Beta = sapply(nickel_pairs, function(x) as.numeric(x$dcc_beta))
    )
    
    cat("\n\n=== NICKEL PAIRWISE DCC-GARCH SUMMARY ===\n")
    kable(nickel_summary_df, digits = 4,
          caption = "Nickel: Pairwise DCC-GARCH Model Results")
    
    # Visualization of fitted pairs
    cat("\n--- NICKEL DCC-GARCH MODEL FITTING VISUALIZATION ---\n\n")
    
    # Create pair matrix
    pair_matrix <- matrix(0, nrow=n_nickel, ncol=n_nickel)
    rownames(pair_matrix) <- colnames(pair_matrix) <- nickel_cols
    
    for(pair in nickel_pairs) {
      i <- which(nickel_cols == pair$pair[1])
      j <- which(nickel_cols == pair$pair[2])
      pair_matrix[i, j] <- 1
      pair_matrix[j, i] <- 1
    }
    
    # Heatmap
    par(mar=c(8,8,3,2))
    image(1:n_nickel, 1:n_nickel, pair_matrix,
          col=c("white", "steelblue"),
          xlab="", ylab="", main="Nickel: DCC-GARCH Pairs Fitted",
          axes=FALSE)
    axis(1, at=1:n_nickel, labels=nickel_cols, las=2, cex.axis=0.7)
    axis(2, at=1:n_nickel, labels=nickel_cols, las=2, cex.axis=0.7)
    abline(h=seq(0.5, n_nickel+0.5, 1), v=seq(0.5, n_nickel+0.5, 1), col="gray80")
    text(n_nickel/2, -1.5, "Blue = Model Fitted", xpd=TRUE, cex=0.9)
    
    # Bar plots
    par(mfrow=c(2,2), mar=c(8,4,3,1))
    
    barplot(nickel_summary_df$AIC, names.arg=1:nrow(nickel_summary_df),
            col="coral", main="AIC by Pair", ylab="AIC", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(nickel_summary_df$Avg_Correlation, names.arg=1:nrow(nickel_summary_df),
            col="darkgreen", main="Average Dynamic Correlation", 
            ylab="Correlation", xlab="Pair Number",
            las=1, border=NA, ylim=c(-1, 1))
    abline(h=0, lty=2)
    
    barplot(nickel_summary_df$DCC_Alpha, names.arg=1:nrow(nickel_summary_df),
            col="purple", main="DCC Alpha (Short-run)", 
            ylab="Alpha", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(nickel_summary_df$DCC_Beta, names.arg=1:nrow(nickel_summary_df),
            col="orange", main="DCC Beta (Long-run)", 
            ylab="Beta", xlab="Pair Number",
            las=1, border=NA)
    
    par(mfrow=c(1,1), mar=c(5,4,4,2))
  }
}
```

```{r dcc-cobalt-pairs}
cat("\n")
cat("================================================================================\n")
cat("                   COBALT - PAIRWISE DCC-GARCH MODELS\n")
cat("================================================================================\n\n")

cobalt_pairs <- list()
cobalt_cols <- colnames(cobalt_returns_mat)
n_cobalt <- length(cobalt_cols)

if(n_cobalt >= 2) {
  pair_idx <- 1
  for(i in 1:(n_cobalt-1)) {
    for(j in (i+1):n_cobalt) {
      result <- fit_dcc_pair(cobalt_returns_mat, i, j, "Cobalt")
      if(!is.null(result)) {
        cobalt_pairs[[pair_idx]] <- result
        pair_idx <- pair_idx + 1
      }
    }
  }
  
  if(length(cobalt_pairs) > 0) {
    cobalt_summary_df <- data.frame(
      Pair = sapply(cobalt_pairs, function(x) paste(x$pair[1], "-", x$pair[2])),
      AIC = sapply(cobalt_pairs, function(x) x$aic),
      BIC = sapply(cobalt_pairs, function(x) x$bic),
      Avg_Correlation = sapply(cobalt_pairs, function(x) x$avg_cor),
      DCC_Alpha = sapply(cobalt_pairs, function(x) as.numeric(x$dcc_alpha)),
      DCC_Beta = sapply(cobalt_pairs, function(x) as.numeric(x$dcc_beta))
    )
    
    cat("\n\n=== COBALT PAIRWISE DCC-GARCH SUMMARY ===\n")
    kable(cobalt_summary_df, digits = 4,
          caption = "Cobalt: Pairwise DCC-GARCH Model Results")
    
    # Visualization of fitted pairs
    cat("\n--- COBALT DCC-GARCH MODEL FITTING VISUALIZATION ---\n\n")
    
    # Create pair matrix
    pair_matrix <- matrix(0, nrow=n_cobalt, ncol=n_cobalt)
    rownames(pair_matrix) <- colnames(pair_matrix) <- cobalt_cols
    
    for(pair in cobalt_pairs) {
      i <- which(cobalt_cols == pair$pair[1])
      j <- which(cobalt_cols == pair$pair[2])
      pair_matrix[i, j] <- 1
      pair_matrix[j, i] <- 1
    }
    
    # Heatmap
    par(mar=c(8,8,3,2))
    image(1:n_cobalt, 1:n_cobalt, pair_matrix,
          col=c("white", "steelblue"),
          xlab="", ylab="", main="Cobalt: DCC-GARCH Pairs Fitted",
          axes=FALSE)
    axis(1, at=1:n_cobalt, labels=cobalt_cols, las=2, cex.axis=0.7)
    axis(2, at=1:n_cobalt, labels=cobalt_cols, las=2, cex.axis=0.7)
    abline(h=seq(0.5, n_cobalt+0.5, 1), v=seq(0.5, n_cobalt+0.5, 1), col="gray80")
    text(n_cobalt/2, -1.5, "Blue = Model Fitted", xpd=TRUE, cex=0.9)
    
    # Bar plots
    par(mfrow=c(2,2), mar=c(8,4,3,1))
    
    barplot(cobalt_summary_df$AIC, names.arg=1:nrow(cobalt_summary_df),
            col="coral", main="AIC by Pair", ylab="AIC", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(cobalt_summary_df$Avg_Correlation, names.arg=1:nrow(cobalt_summary_df),
            col="darkgreen", main="Average Dynamic Correlation", 
            ylab="Correlation", xlab="Pair Number",
            las=1, border=NA, ylim=c(-1, 1))
    abline(h=0, lty=2)
    
    barplot(cobalt_summary_df$DCC_Alpha, names.arg=1:nrow(cobalt_summary_df),
            col="purple", main="DCC Alpha (Short-run)", 
            ylab="Alpha", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(cobalt_summary_df$DCC_Beta, names.arg=1:nrow(cobalt_summary_df),
            col="orange", main="DCC Beta (Long-run)", 
            ylab="Beta", xlab="Pair Number",
            las=1, border=NA)
    
    par(mfrow=c(1,1), mar=c(5,4,4,2))
  }
}
```

```{r dcc-copper-pairs}
cat("\n")
cat("================================================================================\n")
cat("                   COPPER - PAIRWISE DCC-GARCH MODELS\n")
cat("================================================================================\n\n")

copper_pairs <- list()
copper_cols <- colnames(copper_returns_mat)
n_copper <- length(copper_cols)

if(n_copper >= 2) {
  pair_idx <- 1
  for(i in 1:(n_copper-1)) {
    for(j in (i+1):n_copper) {
      result <- fit_dcc_pair(copper_returns_mat, i, j, "Copper")
      if(!is.null(result)) {
        copper_pairs[[pair_idx]] <- result
        pair_idx <- pair_idx + 1
      }
    }
  }
  
  if(length(copper_pairs) > 0) {
    copper_summary_df <- data.frame(
      Pair = sapply(copper_pairs, function(x) paste(x$pair[1], "-", x$pair[2])),
      AIC = sapply(copper_pairs, function(x) x$aic),
      BIC = sapply(copper_pairs, function(x) x$bic),
      Avg_Correlation = sapply(copper_pairs, function(x) x$avg_cor),
      DCC_Alpha = sapply(copper_pairs, function(x) as.numeric(x$dcc_alpha)),
      DCC_Beta = sapply(copper_pairs, function(x) as.numeric(x$dcc_beta))
    )
    
    cat("\n\n=== COPPER PAIRWISE DCC-GARCH SUMMARY ===\n")
    kable(copper_summary_df, digits = 4,
          caption = "Copper: Pairwise DCC-GARCH Model Results")
    
    # Visualization of fitted pairs
    cat("\n--- COPPER DCC-GARCH MODEL FITTING VISUALIZATION ---\n\n")
    
    # Create pair matrix
    pair_matrix <- matrix(0, nrow=n_copper, ncol=n_copper)
    rownames(pair_matrix) <- colnames(pair_matrix) <- copper_cols
    
    for(pair in copper_pairs) {
      i <- which(copper_cols == pair$pair[1])
      j <- which(copper_cols == pair$pair[2])
      pair_matrix[i, j] <- 1
      pair_matrix[j, i] <- 1
    }
    
    # Heatmap
    par(mar=c(8,8,3,2))
    image(1:n_copper, 1:n_copper, pair_matrix,
          col=c("white", "steelblue"),
          xlab="", ylab="", main="Copper: DCC-GARCH Pairs Fitted",
          axes=FALSE)
    axis(1, at=1:n_copper, labels=copper_cols, las=2, cex.axis=0.7)
    axis(2, at=1:n_copper, labels=copper_cols, las=2, cex.axis=0.7)
    abline(h=seq(0.5, n_copper+0.5, 1), v=seq(0.5, n_copper+0.5, 1), col="gray80")
    text(n_copper/2, -1.5, "Blue = Model Fitted", xpd=TRUE, cex=0.9)
    
    # Bar plots
    par(mfrow=c(2,2), mar=c(8,4,3,1))
    
    barplot(copper_summary_df$AIC, names.arg=1:nrow(copper_summary_df),
            col="coral", main="AIC by Pair", ylab="AIC", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(copper_summary_df$Avg_Correlation, names.arg=1:nrow(copper_summary_df),
            col="darkgreen", main="Average Dynamic Correlation", 
            ylab="Correlation", xlab="Pair Number",
            las=1, border=NA, ylim=c(-1, 1))
    abline(h=0, lty=2)
    
    barplot(copper_summary_df$DCC_Alpha, names.arg=1:nrow(copper_summary_df),
            col="purple", main="DCC Alpha (Short-run)", 
            ylab="Alpha", xlab="Pair Number",
            las=1, border=NA)
    
    barplot(copper_summary_df$DCC_Beta, names.arg=1:nrow(copper_summary_df),
            col="orange", main="DCC Beta (Long-run)", 
            ylab="Beta", xlab="Pair Number",
            las=1, border=NA)
    
    par(mfrow=c(1,1), mar=c(5,4,4,2))
  }
}
```

```{r dcc-final-summary}
cat("\n")
cat("================================================================================\n")
cat("                   DCC-GARCH PAIRWISE FITTING COMPLETE\n")
cat("================================================================================\n\n")

cat("MODELS FITTED:\n")
cat(sprintf("  Lithium: %d pairwise combinations\n", length(lithium_pairs)))
cat(sprintf("  Nickel: %d pairwise combinations\n", length(nickel_pairs)))
cat(sprintf("  Cobalt: %d pairwise combinations\n", length(cobalt_pairs)))
cat(sprintf("  Copper: %d pairwise combinations\n", length(copper_pairs)))
cat("\n\n")

cat("DCC-GARCH PARAMETERS:\n")
cat("  DCC Alpha: Short-run persistence of dynamic correlations\n")
cat("  DCC Beta: Long-run persistence of dynamic correlations\n")
cat("  Avg Correlation: Mean dynamic conditional correlation\n\n")

cat("MODEL SELECTION:\n")
cat("  Lower AIC/BIC indicates better model fit\n")
cat("  All models use ARMA(1,1)-GARCH(1,1) for univariate specifications\n")
cat("  DCC(1,1) for multivariate correlation dynamics\n\n")

cat("================================================================================\n\n")
```

```{r dcc-visualization-summary, fig.width=12, fig.height=8}
cat("\n")
cat("================================================================================\n")
cat("           CROSS-METAL DCC-GARCH FITTING VISUALIZATION\n")
cat("================================================================================\n\n")

# Create comprehensive comparison visualization
par(mfrow=c(2,2), mar=c(5,5,3,2))

# 1. Number of pairs fitted per metal
pairs_count <- c(
  Lithium = length(lithium_pairs),
  Nickel = length(nickel_pairs),
  Cobalt = length(cobalt_pairs),
  Copper = length(copper_pairs)
)

barplot(pairs_count, 
        col=c("#E69F00", "#56B4E9", "#009E73", "#F0E442"),
        main="DCC-GARCH Models Fitted by Metal",
        ylab="Number of Pairwise Models",
        border=NA, las=1)
text(x=seq(0.7, by=1.2, length.out=4), y=pairs_count + max(pairs_count)*0.05,
     labels=pairs_count, cex=1.2, font=2)

# 2. Average correlation by metal
if(length(lithium_pairs) > 0 & length(nickel_pairs) > 0 & 
   length(cobalt_pairs) > 0 & length(copper_pairs) > 0) {
  
  avg_corr <- c(
    Lithium = mean(sapply(lithium_pairs, function(x) x$avg_cor)),
    Nickel = mean(sapply(nickel_pairs, function(x) x$avg_cor)),
    Cobalt = mean(sapply(cobalt_pairs, function(x) x$avg_cor)),
    Copper = mean(sapply(copper_pairs, function(x) x$avg_cor))
  )
  
  barplot(avg_corr,
          col=c("#E69F00", "#56B4E9", "#009E73", "#F0E442"),
          main="Average Dynamic Correlation by Metal",
          ylab="Mean Correlation",
          ylim=c(0, 1), border=NA, las=1)
  text(x=seq(0.7, by=1.2, length.out=4), y=avg_corr + 0.05,
       labels=sprintf("%.3f", avg_corr), cex=1, font=2)
  abline(h=0.5, lty=2, col="gray50")
  
  # 3. Average DCC parameters by metal
  avg_alpha <- c(
    Lithium = mean(sapply(lithium_pairs, function(x) as.numeric(x$dcc_alpha))),
    Nickel = mean(sapply(nickel_pairs, function(x) as.numeric(x$dcc_alpha))),
    Cobalt = mean(sapply(cobalt_pairs, function(x) as.numeric(x$dcc_alpha))),
    Copper = mean(sapply(copper_pairs, function(x) as.numeric(x$dcc_alpha)))
  )
  
  avg_beta <- c(
    Lithium = mean(sapply(lithium_pairs, function(x) as.numeric(x$dcc_beta))),
    Nickel = mean(sapply(nickel_pairs, function(x) as.numeric(x$dcc_beta))),
    Cobalt = mean(sapply(cobalt_pairs, function(x) as.numeric(x$dcc_beta))),
    Copper = mean(sapply(copper_pairs, function(x) as.numeric(x$dcc_beta)))
  )
  
  barplot(rbind(avg_alpha, avg_beta),
          beside=TRUE,
          col=c("purple", "orange"),
          names.arg=c("Lithium", "Nickel", "Cobalt", "Copper"),
          main="Average DCC Parameters by Metal",
          ylab="Parameter Value",
          legend.text=c("Alpha (Short-run)", "Beta (Long-run)"),
          args.legend=list(x="topright", bty="n", cex=0.8),
          border=NA, las=1)
  
  # 4. Model quality comparison (AIC)
  avg_aic <- c(
    Lithium = mean(sapply(lithium_pairs, function(x) x$aic)),
    Nickel = mean(sapply(nickel_pairs, function(x) x$aic)),
    Cobalt = mean(sapply(cobalt_pairs, function(x) x$aic)),
    Copper = mean(sapply(copper_pairs, function(x) x$aic))
  )
  
  barplot(avg_aic,
          col=c("#E69F00", "#56B4E9", "#009E73", "#F0E442"),
          main="Average AIC by Metal",
          ylab="AIC (lower is better)",
          border=NA, las=1)
  text(x=seq(0.7, by=1.2, length.out=4), y=avg_aic + max(avg_aic)*0.02,
       labels=sprintf("%.1f", avg_aic), cex=0.9, font=2)
}

par(mfrow=c(1,1), mar=c(5,4,4,2))

# Create detailed summary table
cat("\n\n=== COMPREHENSIVE DCC-GARCH FITTING SUMMARY ===\n\n")

if(length(lithium_pairs) > 0 & length(nickel_pairs) > 0 & 
   length(cobalt_pairs) > 0 & length(copper_pairs) > 0) {
  
  summary_table <- data.frame(
    Metal = c("Lithium", "Nickel", "Cobalt", "Copper"),
    N_Pairs = pairs_count,
    Avg_Correlation = avg_corr,
    SD_Correlation = c(
      sd(sapply(lithium_pairs, function(x) x$avg_cor)),
      sd(sapply(nickel_pairs, function(x) x$avg_cor)),
      sd(sapply(cobalt_pairs, function(x) x$avg_cor)),
      sd(sapply(copper_pairs, function(x) x$avg_cor))
    ),
    Avg_Alpha = avg_alpha,
    Avg_Beta = avg_beta,
    Avg_AIC = avg_aic,
    Avg_BIC = c(
      mean(sapply(lithium_pairs, function(x) x$bic)),
      mean(sapply(nickel_pairs, function(x) x$bic)),
      mean(sapply(cobalt_pairs, function(x) x$bic)),
      mean(sapply(copper_pairs, function(x) x$bic))
    )
  )
  
  kable(summary_table, digits=4,
        caption="DCC-GARCH Model Summary Across All Metals",
        col.names=c("Metal", "# Pairs", "Avg Corr", "SD Corr", 
                    "Avg ", "Avg ", "Avg AIC", "Avg BIC"))
  
  cat("\n\n=== MODEL INTERPRETATION ===\n")
  cat("High Average Correlation: Pairs within the metal move together strongly\n")
  cat("High Alpha: Strong short-run dynamic adjustment in correlations\n")
  cat("High Beta: Strong long-run persistence in correlations\n")
  cat("Alpha + Beta  1: Highly persistent correlation dynamics\n\n")
}

cat("================================================================================\n\n")
```

# VISUAL SUMMARY

```{r visual-summary, fig.width=12, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("                         COMPREHENSIVE VISUAL SUMMARY\n")
cat("================================================================================\n\n")

# 1. Unit Root Tests Overview - Stationarity across all metals
cat("\n--- STATIONARITY STATUS ACROSS ALL METALS ---\n\n")

all_unit_root_summary <- rbind(
  data.frame(Metal="Lithium", lithium_summary_table[,c("Series", "ADF_Result", "PP_Result", "KPSS_Result", "DFGLS_Result")]),
  data.frame(Metal="Nickel", nickel_summary_table[,c("Series", "ADF_Result", "PP_Result", "KPSS_Result", "DFGLS_Result")]),
  data.frame(Metal="Cobalt", cobalt_summary_table[,c("Series", "ADF_Result", "PP_Result", "KPSS_Result", "DFGLS_Result")]),
  data.frame(Metal="Copper", copper_summary_table[,c("Series", "ADF_Result", "PP_Result", "KPSS_Result", "DFGLS_Result")])
)

# Count stationary series per metal
stationarity_counts <- aggregate(
  cbind(ADF = ADF_Result == "Stationary",
        PP = PP_Result == "Stationary", 
        KPSS = KPSS_Result == "Stationary",
        DFGLS = DFGLS_Result == "Stationary") ~ Metal,
  data = all_unit_root_summary,
  FUN = sum
)

kable(stationarity_counts, caption = "Number of Stationary Series per Metal (by Test)")

# Stationarity comparison plot
par(mar=c(5,5,4,2))
barplot(t(as.matrix(stationarity_counts[,-1])), 
        beside=TRUE, 
        names.arg=stationarity_counts$Metal,
        col=c("steelblue", "darkgreen", "coral", "purple"),
        main="Stationarity Test Results Comparison",
        ylab="Number of Stationary Series",
        legend.text=c("ADF", "PP", "KPSS", "DF-GLS"),
        args.legend=list(x="topright", bty="n"))

# 2. DCC-GARCH Summary Statistics
cat("\n\n--- DCC-GARCH PAIRWISE MODEL SUMMARY ---\n\n")

summary_stats <- data.frame(
  Metal = c("Lithium", "Nickel", "Cobalt", "Copper"),
  N_Series = c(ncol(lithium_returns_mat), ncol(nickel_returns_mat), 
               ncol(cobalt_returns_mat), ncol(copper_returns_mat)),
  N_Pairs = c(length(lithium_pairs), length(nickel_pairs),
              length(cobalt_pairs), length(copper_pairs)),
  N_Stationary_ADF = stationarity_counts$ADF,
  N_Stationary_PP = stationarity_counts$PP,
  N_Stationary_KPSS = stationarity_counts$KPSS
)

kable(summary_stats, digits=2,
      caption="Comprehensive Summary: Unit Root Tests and DCC-GARCH Pairwise Models",
      col.names=c("Metal", "# Series", "# Pairs Fitted", "ADF", "PP", "KPSS"))

cat("\n\n")
cat("================================================================================\n")
cat("                    ANALYSIS COMPLETE - ALL VISUALIZATIONS GENERATED\n")
cat("================================================================================\n\n")
```