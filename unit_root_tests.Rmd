---
title: "Unit Root Tests for Metals Price Series"
output: 
  html_document:
    self_contained: true
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
knitr::opts_knit$set(root.dir = getwd()) 

# Required packages
# urca: Most comprehensive and robust package for unit root tests
# tseries: Additional unit root tests
pkgs <- c("urca", "tseries", "dplyr", "knitr")
missing <- pkgs[!(pkgs %in% installed.packages()[,"Package"])]
if(length(missing)) install.packages(missing)
lapply(pkgs, library, character.only = TRUE)
```

```{r load-data}
# Load data
lithium = read.csv("data/ALL_lithium_prices_cubic_spline.csv")
nickel = read.csv("data/ALL_nickel_prices_cubic_spline.csv")
cobalt = read.csv("data/ALL_cobalt_prices_cubic_spline.csv")
copper = read.csv("data/ALL_copper_prices_cubic_spline.csv")

# Convert Date columns
lithium$Date <- as.Date(lithium$Date)
nickel$Date  <- as.Date(nickel$Date)
cobalt$Date  <- as.Date(cobalt$Date)
copper$Date  <- as.Date(copper$Date)

# Remove LISAME from lithium
lithium <- subset(lithium, select = -LISAME)

# Get price columns
lithium_prices <- lithium[, -1]
nickel_prices <- nickel[, -1]
cobalt_prices <- cobalt[, -1]
copper_prices <- copper[, -1]

cat("\n=== DATA LOADED ===\n")
cat("Lithium series:", ncol(lithium_prices), "\n")
cat("Nickel series:", ncol(nickel_prices), "\n")
cat("Cobalt series:", ncol(cobalt_prices), "\n")
cat("Copper series:", ncol(copper_prices), "\n\n")

# Calculate returns (percentage returns)
calculate_returns <- function(prices) {
  returns <- lapply(1:ncol(prices), function(i) {
    x <- prices[, i]
    x <- na.omit(x)
    ret <- (diff(x) / x[-length(x)]) * 100  # Simple returns in percentage
    return(ret)
  })
  names(returns) <- colnames(prices)
  return(returns)
}

lithium_returns <- calculate_returns(lithium_prices)
nickel_returns <- calculate_returns(nickel_prices)
cobalt_returns <- calculate_returns(cobalt_prices)
copper_returns <- calculate_returns(copper_prices)

cat("\n=== RETURNS CALCULATED ===\n")
cat("Returns are calculated as: (Price_t - Price_{t-1}) / Price_{t-1} * 100\n")
cat("This gives percentage simple returns\n")
cat("Lithium return series:", length(lithium_returns), "\n")
cat("Nickel return series:", length(nickel_returns), "\n")
cat("Cobalt return series:", length(cobalt_returns), "\n")
cat("Copper return series:", length(copper_returns), "\n\n")
```

```{r helper-functions}
# Helper function to interpret unit root test results
interpret_adf <- function(test_result, series_name) {
  cat("\n--- INTERPRETATION for", series_name, "---\n")
  
  test_stat <- as.numeric(test_result@teststat)[1]
  crit_vals <- test_result@cval
  
  cat("Test Statistic:", round(test_stat, 4), "\n")
  cat("Critical Values: 1%=", round(crit_vals[1], 4), 
      ", 5%=", round(crit_vals[2], 4), 
      ", 10%=", round(crit_vals[3], 4), "\n")
  
  if(test_stat < crit_vals[3]) {
    cat("RESULT: REJECT null hypothesis at 10% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else if(test_stat < crit_vals[2]) {
    cat("RESULT: REJECT null hypothesis at 5% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else if(test_stat < crit_vals[1]) {
    cat("RESULT: REJECT null hypothesis at 1% level\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
}

interpret_kpss <- function(test_result, series_name) {
  cat("\n--- INTERPRETATION for", series_name, "---\n")
  
  test_stat <- as.numeric(test_result@teststat)[1]
  crit_vals <- test_result@cval
  
  cat("Test Statistic:", round(test_stat, 4), "\n")
  cat("Critical Values: 10%=", round(crit_vals[1], 4), 
      ", 5%=", round(crit_vals[2], 4), 
      ", 2.5%=", round(crit_vals[3], 4),
      ", 1%=", round(crit_vals[4], 4), "\n")
  
  if(test_stat > crit_vals[4]) {
    cat("RESULT: REJECT null hypothesis at 1% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[3]) {
    cat("RESULT: REJECT null hypothesis at 2.5% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[2]) {
    cat("RESULT: REJECT null hypothesis at 5% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else if(test_stat > crit_vals[1]) {
    cat("RESULT: REJECT null hypothesis at 10% level\n")
    cat("CONCLUSION: Series", series_name, "is NON-STATIONARY (has unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series", series_name, "is STATIONARY (no unit root)\n")
  }
}
```

# LITHIUM UNIT ROOT TESTS

```{r lithium-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    LITHIUM RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

lithium_results <- list()

for(i in 1:length(lithium_returns)) {
  series_name <- names(lithium_returns)[i]
  series_data <- lithium_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: LITHIUM -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. Augmented Dickey-Fuller (ADF) Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Lithium", series_name))
  
  # 2. Phillips-Perron (PP) Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Lithium", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n")
  cat("NOTE: This test has OPPOSITE hypotheses compared to ADF and PP tests!\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Lithium", series_name))
  
  # 4. DF-GLS Test (Elliott-Rothenberg-Stock)
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n")
  cat("NOTE: This is an improved version of ADF with better power\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Lithium", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Lithium", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # Store results
  lithium_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Lithium
lithium_summary_table <- data.frame(
  Series = names(lithium_results),
  ADF_Stat = sapply(lithium_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(lithium_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(lithium_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(lithium_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(lithium_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(lithium_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(lithium_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(lithium_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== LITHIUM UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(lithium_summary_table, 
      caption = "Lithium Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(lithium_summary_table$ADF_Stat, names.arg=lithium_summary_table$Series, 
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$PP_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$KPSS_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(lithium_summary_table$DFGLS_Stat, names.arg=lithium_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(lithium_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# NICKEL UNIT ROOT TESTS

```{r nickel-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    NICKEL RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

nickel_results <- list()

for(i in 1:length(nickel_returns)) {
  series_name <- names(nickel_returns)[i]
  series_data <- nickel_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: NICKEL -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Nickel", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Nickel", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Nickel", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Nickel", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Nickel", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  nickel_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Nickel
nickel_summary_table <- data.frame(
  Series = names(nickel_results),
  ADF_Stat = sapply(nickel_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(nickel_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(nickel_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(nickel_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(nickel_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(nickel_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(nickel_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(nickel_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== NICKEL UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(nickel_summary_table,
      caption = "Nickel Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(nickel_summary_table$ADF_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$PP_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$KPSS_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(nickel_summary_table$DFGLS_Stat, names.arg=nickel_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(nickel_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# COBALT UNIT ROOT TESTS

```{r cobalt-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    COBALT RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

cobalt_results <- list()

for(i in 1:length(cobalt_returns)) {
  series_name <- names(cobalt_returns)[i]
  series_data <- cobalt_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: COBALT -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Cobalt", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Cobalt", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Cobalt", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Cobalt", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Cobalt", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  cobalt_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Cobalt
cobalt_summary_table <- data.frame(
  Series = names(cobalt_results),
  ADF_Stat = sapply(cobalt_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(cobalt_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(cobalt_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(cobalt_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(cobalt_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(cobalt_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(cobalt_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(cobalt_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== COBALT UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(cobalt_summary_table,
      caption = "Cobalt Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(cobalt_summary_table$ADF_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$PP_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$KPSS_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(cobalt_summary_table$DFGLS_Stat, names.arg=cobalt_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(cobalt_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# COPPER UNIT ROOT TESTS

```{r copper-unit-root}
cat("\n")
cat("================================================================================\n")
cat("                    COPPER RETURNS - UNIT ROOT TESTS\n")
cat("================================================================================\n\n")

copper_results <- list()

for(i in 1:length(copper_returns)) {
  series_name <- names(copper_returns)[i]
  series_data <- copper_returns[[i]]
  series_data <- na.omit(series_data)
  
  cat("\n")
  cat("========================================\n")
  cat("SERIES: COPPER -", series_name, "\n")
  cat("========================================\n\n")
  
  # 1. ADF Test
  cat("--- 1. AUGMENTED DICKEY-FULLER (ADF) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  adf_test <- ur.df(series_data, type = "trend", lags = 5, selectlags = "AIC")
  print(summary(adf_test))
  interpret_adf(adf_test, paste("Copper", series_name))
  
  # 2. PP Test
  cat("\n\n--- 2. PHILLIPS-PERRON (PP) TEST ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  pp_test <- ur.pp(series_data, type = "Z-tau", model = "trend", lags = "short")
  print(summary(pp_test))
  
  cat("\n--- INTERPRETATION for Copper", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(pp_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(pp_test@cval[1], 4), 
      ", 5%=", round(pp_test@cval[2], 4), 
      ", 10%=", round(pp_test@cval[3], 4), "\n")
  
  if(as.numeric(pp_test@teststat)[1] < pp_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  # 3. KPSS Test
  cat("\n\n--- 3. KPSS STATIONARITY TEST ---\n")
  cat("Null Hypothesis: Series is stationary\n")
  cat("Alternative Hypothesis: Series has a unit root (non-stationary)\n\n")
  
  kpss_test <- ur.kpss(series_data, type = "tau", lags = "short")
  print(summary(kpss_test))
  interpret_kpss(kpss_test, paste("Copper", series_name))
  
  # 4. DF-GLS Test
  cat("\n\n--- 4. DF-GLS TEST (Elliott-Rothenberg-Stock) ---\n")
  cat("Null Hypothesis: Series has a unit root (non-stationary)\n")
  cat("Alternative Hypothesis: Series is stationary\n\n")
  
  ers_test <- ur.ers(series_data, type = "DF-GLS", model = "trend", lag.max = 5)
  print(summary(ers_test))
  
  cat("\n--- INTERPRETATION for Copper", series_name, "---\n")
  cat("Test Statistic:", round(as.numeric(ers_test@teststat)[1], 4), "\n")
  cat("Critical Values: 1%=", round(ers_test@cval[1], 4), 
      ", 5%=", round(ers_test@cval[2], 4), 
      ", 10%=", round(ers_test@cval[3], 4), "\n")
  
  if(as.numeric(ers_test@teststat)[1] < ers_test@cval[3]) {
    cat("RESULT: REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "is STATIONARY (no unit root)\n")
  } else {
    cat("RESULT: FAIL TO REJECT null hypothesis\n")
    cat("CONCLUSION: Series Copper", series_name, "has a UNIT ROOT (non-stationary)\n")
  }
  
  copper_results[[series_name]] <- list(
    adf = adf_test,
    pp = pp_test,
    kpss = kpss_test,
    ers = ers_test
  )
  
  cat("\n")
  cat("========================================\n\n")
}

# Create summary table for Copper
copper_summary_table <- data.frame(
  Series = names(copper_results),
  ADF_Stat = sapply(copper_results, function(x) round(x$adf@teststat[1], 4)),
  ADF_Result = sapply(copper_results, function(x) ifelse(x$adf@teststat[1] < x$adf@cval[3], "Stationary", "Non-Stationary")),
  PP_Stat = sapply(copper_results, function(x) round(x$pp@teststat[1], 4)),
  PP_Result = sapply(copper_results, function(x) ifelse(x$pp@teststat[1] < x$pp@cval[3], "Stationary", "Non-Stationary")),
  KPSS_Stat = sapply(copper_results, function(x) round(x$kpss@teststat[1], 4)),
  KPSS_Result = sapply(copper_results, function(x) ifelse(x$kpss@teststat[1] > x$kpss@cval[2], "Non-Stationary", "Stationary")),
  DFGLS_Stat = sapply(copper_results, function(x) round(x$ers@teststat[1], 4)),
  DFGLS_Result = sapply(copper_results, function(x) ifelse(x$ers@teststat[1] < x$ers@cval[3], "Stationary", "Non-Stationary"))
)

cat("\n=== COPPER UNIT ROOT TESTS SUMMARY TABLE ===\n\n")
kable(copper_summary_table,
      caption = "Copper Returns: Unit Root Test Results Summary",
      col.names = c("Series", "ADF Stat", "ADF", "PP Stat", "PP", "KPSS Stat", "KPSS", "DF-GLS Stat", "DF-GLS"))

# Plot test statistics
par(mfrow=c(2,2), mar=c(8,4,2,1))
barplot(copper_summary_table$ADF_Stat, names.arg=copper_summary_table$Series,
        las=2, col="steelblue", main="ADF Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$adf@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$PP_Stat, names.arg=copper_summary_table$Series,
        las=2, col="darkgreen", main="Phillips-Perron Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$pp@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$KPSS_Stat, names.arg=copper_summary_table$Series,
        las=2, col="coral", main="KPSS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$kpss@cval[2])), col="red", lty=2, lwd=2)

barplot(copper_summary_table$DFGLS_Stat, names.arg=copper_summary_table$Series,
        las=2, col="purple", main="DF-GLS Test Statistics", ylab="Test Statistic",
        cex.names=0.7)
abline(h=mean(sapply(copper_results, function(x) x$ers@cval[2])), col="red", lty=2, lwd=2)
par(mfrow=c(1,1))
```

# DCC-GARCH MODEL SELECTION

```{r dcc-setup, message=FALSE, warning=FALSE}
cat("\n")
cat("================================================================================\n")
cat("              DCC-GARCH MODEL SELECTION AND ESTIMATION\n")
cat("================================================================================\n\n")

# Install and load ConnectednessApproach package
if (!require("ConnectednessApproach", quietly = TRUE)) {
  if (!require("devtools", quietly = TRUE)) {
    install.packages("devtools")
  }
  library(devtools)
  install_github("GabauerDavid/ConnectednessApproach")
}

library(ConnectednessApproach)
library(xts)
library(knitr)

cat("=== PACKAGE LOADED ===\n")
cat("ConnectednessApproach: DCC-GARCH model selection and estimation\n")
cat("Function: DCCGARCHselection() - Selects best DCC-GARCH specification\n\n")
```

```{r prepare-dcc-data}
cat("\n=== PREPARING DATA FOR DCC-GARCH ===\n\n")

# Prepare return data as xts objects with proper dates
prepare_return_xts <- function(returns_list, dates) {
  n_series <- length(returns_list)
  series_names <- names(returns_list)
  min_len <- min(sapply(returns_list, length))
  
  return_matrix <- matrix(NA, nrow = min_len, ncol = n_series)
  colnames(return_matrix) <- series_names
  
  for(i in 1:n_series) {
    return_matrix[, i] <- returns_list[[i]][1:min_len]
  }
  
  # Create xts object with proper dates (skip first date due to differencing)
  return_xts <- xts(return_matrix, order.by = dates[2:(min_len+1)])
  
  # Clean data: remove any NAs, Inf, or extreme values
  return_xts <- na.omit(return_xts)
  
  # Replace infinite values with NA and remove
  return_xts[is.infinite(return_xts)] <- NA
  return_xts <- na.omit(return_xts)
  
  # Remove extreme outliers (beyond 10 standard deviations)
  for(i in 1:ncol(return_xts)) {
    col_mean <- mean(return_xts[,i], na.rm=TRUE)
    col_sd <- sd(return_xts[,i], na.rm=TRUE)
    outliers <- abs(return_xts[,i] - col_mean) > 10 * col_sd
    if(any(outliers, na.rm=TRUE)) {
      return_xts[outliers, i] <- NA
    }
  }
  return_xts <- na.omit(return_xts)
  
  return(return_xts)
}

# Prepare data for each metal
lithium_xts <- prepare_return_xts(lithium_returns, lithium$Date)
nickel_xts <- prepare_return_xts(nickel_returns, nickel$Date)
cobalt_xts <- prepare_return_xts(cobalt_returns, cobalt$Date)
copper_xts <- prepare_return_xts(copper_returns, copper$Date)

cat("Data prepared and cleaned as xts objects:\n")
cat("  Lithium:", nrow(lithium_xts), "observations x", ncol(lithium_xts), "series\n")
cat("  Nickel:", nrow(nickel_xts), "observations x", ncol(nickel_xts), "series\n")
cat("  Cobalt:", nrow(cobalt_xts), "observations x", ncol(cobalt_xts), "series\n")
cat("  Copper:", nrow(copper_xts), "observations x", ncol(copper_xts), "series\n\n")

cat("Data cleaning steps applied:\n")
cat("  - Removed NA values\n")
cat("  - Removed infinite values\n")
cat("  - Removed extreme outliers (>10 SD from mean)\n\n")
```

```{r diagnose-data}
cat("\n=== DATA DIAGNOSTICS ===\n\n")

# Function to diagnose data quality
diagnose_data <- function(xts_data, name) {
  cat("\n--- ", name, " ---\n")
  cat("  Dimensions:", nrow(xts_data), "rows x", ncol(xts_data), "columns\n")
  cat("  Date range:", as.character(start(xts_data)), "to", as.character(end(xts_data)), "\n")
  
  # Check for constant series (zero variance)
  variances <- apply(xts_data, 2, var, na.rm=TRUE)
  zero_var <- sum(variances < 1e-10)
  if(zero_var > 0) {
    cat("  WARNING:", zero_var, "series with near-zero variance\n")
  }
  
  # Check basic stats
  cat("  Mean returns range:", sprintf("%.4f to %.4f", 
      min(colMeans(xts_data, na.rm=TRUE)), max(colMeans(xts_data, na.rm=TRUE))), "\n")
  cat("  SD range:", sprintf("%.4f to %.4f", 
      min(apply(xts_data, 2, sd, na.rm=TRUE)), max(apply(xts_data, 2, sd, na.rm=TRUE))), "\n")
}

diagnose_data(lithium_xts, "Lithium")
diagnose_data(nickel_xts, "Nickel")
diagnose_data(cobalt_xts, "Cobalt")
diagnose_data(copper_xts, "Copper")
```

```{r dcc-lithium, fig.width=12, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("                   LITHIUM - DCC-GARCH ANALYSIS\n")
cat("================================================================================\n\n")

# Limit to first 4 series for computational efficiency
max_series <- min(4, ncol(lithium_xts))
lithium_subset <- lithium_xts[, 1:max_series]

cat("Using", max_series, "series for DCC-GARCH analysis:\n")
cat(paste("  -", colnames(lithium_subset), collapse="\n"), "\n\n")

# Manual DCC-GARCH fitting with fixed specification (faster than model selection)
cat("Fitting DCC-GARCH(1,1) with Student-t distribution...\n")

lithium_dcc <- tryCatch({
  library(rmgarch)
  
  # Simple GARCH(1,1) specification for each series
  garch_spec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                           variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
                           distribution.model = "std")
  
  # Replicate spec for all series
  multi_spec <- multispec(replicate(max_series, garch_spec))
  
  # DCC specification
  dcc_spec <- dccspec(uspec = multi_spec, 
                      dccOrder = c(1,1), 
                      distribution = "mvt")
  
  cat("  Fitting univariate GARCH models...\n")
  dcc_fit <- dccfit(dcc_spec, data = lithium_subset, 
                    fit.control = list(eval.se=FALSE))
  
  cat("  ✓ Model fitted successfully!\n\n")
  dcc_fit
}, error = function(e) {
  cat("  ✗ Error:", e$message, "\n\n")
  return(NULL)
})

if(!is.null(lithium_dcc)) {
  cat("\n=== LITHIUM DCC-GARCH RESULTS ===\n\n")
  
  # Extract DCC parameters
  dcc_params <- coef(lithium_dcc, type="dcc")
  cat("DCC Parameters:\n")
  print(dcc_params)
  cat("\n")
  
  # Get information criteria
  cat("Model Information Criteria:\n")
  cat("  Log-Likelihood:", sprintf("%.2f", likelihood(lithium_dcc)), "\n")
  cat("  AIC:", sprintf("%.2f", infocriteria(lithium_dcc)[1]), "\n")
  cat("  BIC:", sprintf("%.2f", infocriteria(lithium_dcc)[2]), "\n\n")
  
  # Visualizations
  cat("\n=== LITHIUM DCC-GARCH VISUALIZATIONS ===\n\n")
  
  # Extract dynamic correlations
  dcc_cor <- rcor(lithium_dcc)
  n_series <- dim(dcc_cor)[2]
  
  # Plot 1: Time-varying correlations for selected pairs
  par(mfrow=c(2,2), mar=c(4,4,3,2))
  
  plot_count <- 0
  for(i in 1:(n_series-1)) {
    for(j in (i+1):n_series) {
      if(plot_count < 4) {
        cor_series <- dcc_cor[i,j,]
        plot(as.Date(names(cor_series)), cor_series, type="l",
             main=paste("DCC:", colnames(lithium_subset)[i], "-", colnames(lithium_subset)[j]),
             xlab="Date", ylab="Correlation", col="steelblue", lwd=2)
        abline(h=mean(cor_series, na.rm=TRUE), col="red", lty=2, lwd=2)
        grid()
        plot_count <- plot_count + 1
      }
    }
  }
  par(mfrow=c(1,1))
  
  # Plot 2: Average correlations heatmap
  avg_corr_matrix <- matrix(0, nrow=n_series, ncol=n_series)
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      avg_corr_matrix[i,j] <- mean(dcc_cor[i,j,], na.rm=TRUE)
    }
  }
  rownames(avg_corr_matrix) <- colnames(avg_corr_matrix) <- colnames(lithium_subset)
  
  par(mar=c(8,8,4,4))
  image(1:n_series, 1:n_series, avg_corr_matrix,
        col=colorRampPalette(c("blue", "white", "red"))(100),
        xlab="", ylab="", main="Lithium: Average Dynamic Correlations",
        axes=FALSE, zlim=c(-1,1))
  axis(1, at=1:n_series, labels=colnames(lithium_subset), las=2, cex.axis=0.8)
  axis(2, at=1:n_series, labels=colnames(lithium_subset), las=2, cex.axis=0.8)
  
  # Add correlation values
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      text(i, j, sprintf("%.2f", avg_corr_matrix[i,j]), cex=0.8)
    }
  }
  par(mar=c(5,4,4,2))
} else {
  cat("\n*** DCC-GARCH model fitting failed for Lithium ***\n")
  cat("Skipping visualizations.\n\n")
}

cat("\n=== LITHIUM DCC-GARCH SECTION COMPLETE ===\n")
```

```{r dcc-nickel, fig.width=12, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("                   NICKEL - DCC-GARCH ANALYSIS\n")
cat("================================================================================\n\n")

# Limit to first 4 series for computational efficiency
max_series <- min(4, ncol(nickel_xts))
nickel_subset <- nickel_xts[, 1:max_series]

cat("Using", max_series, "series for DCC-GARCH analysis:\n")
cat(paste("  -", colnames(nickel_subset), collapse="\n"), "\n\n")

cat("Fitting DCC-GARCH(1,1) with Student-t distribution...\n")

nickel_dcc <- tryCatch({
  library(rmgarch)
  
  garch_spec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                           variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
                           distribution.model = "std")
  multi_spec <- multispec(replicate(max_series, garch_spec))
  dcc_spec <- dccspec(uspec = multi_spec, dccOrder = c(1,1), distribution = "mvt")
  
  cat("  Fitting univariate GARCH models...\n")
  dcc_fit <- dccfit(dcc_spec, data = nickel_subset, fit.control = list(eval.se=FALSE))
  
  cat("  ✓ Model fitted successfully!\n\n")
  dcc_fit
}, error = function(e) {
  cat("  ✗ Error:", e$message, "\n\n")
  return(NULL)
})

if(!is.null(nickel_dcc)) {
  cat("\n=== NICKEL DCC-GARCH RESULTS ===\n\n")
  
  dcc_params <- coef(nickel_dcc, type="dcc")
  cat("DCC Parameters:\n")
  print(dcc_params)
  cat("\n")
  
  cat("Model Information Criteria:\n")
  cat("  Log-Likelihood:", sprintf("%.2f", likelihood(nickel_dcc)), "\n")
  cat("  AIC:", sprintf("%.2f", infocriteria(nickel_dcc)[1]), "\n")
  cat("  BIC:", sprintf("%.2f", infocriteria(nickel_dcc)[2]), "\n\n")
  
  cat("\n=== NICKEL DCC-GARCH VISUALIZATIONS ===\n\n")
  
  dcc_cor <- rcor(nickel_dcc)
  n_series <- dim(dcc_cor)[2]
  
  par(mfrow=c(2,2), mar=c(4,4,3,2))
  plot_count <- 0
  for(i in 1:(n_series-1)) {
    for(j in (i+1):n_series) {
      if(plot_count < 4) {
        cor_series <- dcc_cor[i,j,]
        plot(as.Date(names(cor_series)), cor_series, type="l",
             main=paste("DCC:", colnames(nickel_subset)[i], "-", colnames(nickel_subset)[j]),
             xlab="Date", ylab="Correlation", col="darkgreen", lwd=2)
        abline(h=mean(cor_series, na.rm=TRUE), col="red", lty=2, lwd=2)
        grid()
        plot_count <- plot_count + 1
      }
    }
  }
  par(mfrow=c(1,1))
  
  avg_corr_matrix <- matrix(0, nrow=n_series, ncol=n_series)
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      avg_corr_matrix[i,j] <- mean(dcc_cor[i,j,], na.rm=TRUE)
    }
  }
  rownames(avg_corr_matrix) <- colnames(avg_corr_matrix) <- colnames(nickel_subset)
  
  par(mar=c(8,8,4,4))
  image(1:n_series, 1:n_series, avg_corr_matrix,
        col=colorRampPalette(c("blue", "white", "red"))(100),
        xlab="", ylab="", main="Nickel: Average Dynamic Correlations",
        axes=FALSE, zlim=c(-1,1))
  axis(1, at=1:n_series, labels=colnames(nickel_subset), las=2, cex.axis=0.8)
  axis(2, at=1:n_series, labels=colnames(nickel_subset), las=2, cex.axis=0.8)
  
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      text(i, j, sprintf("%.2f", avg_corr_matrix[i,j]), cex=0.8)
    }
  }
  par(mar=c(5,4,4,2))
} else {
  cat("\n*** DCC-GARCH model fitting failed for Nickel ***\n")
  cat("Skipping visualizations.\n\n")
}

cat("\n=== NICKEL DCC-GARCH SECTION COMPLETE ===\n")
```

```{r dcc-cobalt, fig.width=12, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("                   COBALT - DCC-GARCH ANALYSIS\n")
cat("================================================================================\n\n")

# Diagnose correlation issues first
cat("Diagnosing correlation structure...\n")
cobalt_cor <- cor(cobalt_xts)
cat("Correlation matrix:\n")
print(round(cobalt_cor, 3))
cat("\n")

# Find highly correlated pairs
high_cor <- which(abs(cobalt_cor) > 0.99 & cobalt_cor < 1, arr.ind=TRUE)
if(nrow(high_cor) > 0) {
  cat("WARNING: Found", nrow(high_cor)/2, "pairs with correlation > 0.99\n")
  for(i in 1:(nrow(high_cor)/2)) {
    idx <- high_cor[i,]
    cat("  ", colnames(cobalt_xts)[idx[1]], "-", colnames(cobalt_xts)[idx[2]], 
        ": r =", round(cobalt_cor[idx[1], idx[2]], 4), "\n")
  }
  cat("\n")
}

# Try with only 2 series to avoid singularity (use least correlated pair)
# Find the pair with lowest correlation
min_cor_val <- 1
best_pair <- c(1, 2)
for(i in 1:(ncol(cobalt_xts)-1)) {
  for(j in (i+1):ncol(cobalt_xts)) {
    if(abs(cobalt_cor[i,j]) < min_cor_val) {
      min_cor_val <- abs(cobalt_cor[i,j])
      best_pair <- c(i, j)
    }
  }
}

cat("Attempting fit with 2 least correlated series to avoid singularity:\n")
cat("  Selected:", colnames(cobalt_xts)[best_pair[1]], "and", 
    colnames(cobalt_xts)[best_pair[2]], "\n")
cat("  Correlation:", round(cobalt_cor[best_pair[1], best_pair[2]], 4), "\n\n")

cobalt_subset <- cobalt_xts[, best_pair]

cat("Fitting DCC-GARCH(1,1) with Student-t distribution...\n")

cobalt_dcc <- tryCatch({
  library(rmgarch)
  
  garch_spec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                           variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
                           distribution.model = "std")
  multi_spec <- multispec(replicate(2, garch_spec))
  dcc_spec <- dccspec(uspec = multi_spec, dccOrder = c(1,1), distribution = "mvt")
  
  cat("  Fitting univariate GARCH models...\n")
  dcc_fit <- dccfit(dcc_spec, data = cobalt_subset, fit.control = list(eval.se=FALSE))
  
  cat("  ✓ Model fitted successfully!\n\n")
  dcc_fit
}, error = function(e) {
  cat("  ✗ Error:", e$message, "\n\n")
  return(NULL)
})

if(!is.null(cobalt_dcc)) {
  cat("\n=== COBALT DCC-GARCH RESULTS ===\n\n")
  
  dcc_params <- coef(cobalt_dcc, type="dcc")
  cat("DCC Parameters:\n")
  print(dcc_params)
  cat("\n")
  
  cat("Model Information Criteria:\n")
  cat("  Log-Likelihood:", sprintf("%.2f", likelihood(cobalt_dcc)), "\n")
  cat("  AIC:", sprintf("%.2f", infocriteria(cobalt_dcc)[1]), "\n")
  cat("  BIC:", sprintf("%.2f", infocriteria(cobalt_dcc)[2]), "\n\n")
  
  cat("\n=== COBALT DCC-GARCH VISUALIZATIONS ===\n\n")
  
  dcc_cor <- rcor(cobalt_dcc)
  n_series <- dim(dcc_cor)[2]
  
  # For 2 series, just plot the single correlation time series
  par(mfrow=c(1,2), mar=c(4,4,3,2))
  
  cor_series <- dcc_cor[1,2,]
  plot(as.Date(names(cor_series)), cor_series, type="l",
       main=paste("DCC:", colnames(cobalt_subset)[1], "-", colnames(cobalt_subset)[2]),
       xlab="Date", ylab="Correlation", col="purple", lwd=2)
  abline(h=mean(cor_series, na.rm=TRUE), col="red", lty=2, lwd=2)
  grid()
  
  # Histogram of correlations
  hist(cor_series, breaks=30, col="purple", border="white",
       main="Distribution of Dynamic Correlations",
       xlab="Correlation", ylab="Frequency")
  abline(v=mean(cor_series, na.rm=TRUE), col="red", lwd=2, lty=2)
  
  par(mfrow=c(1,1))
  
  # Summary statistics
  cat("\nDynamic Correlation Statistics:\n")
  cat("  Mean:", sprintf("%.4f", mean(cor_series, na.rm=TRUE)), "\n")
  cat("  Min:", sprintf("%.4f", min(cor_series, na.rm=TRUE)), "\n")
  cat("  Max:", sprintf("%.4f", max(cor_series, na.rm=TRUE)), "\n")
  cat("  SD:", sprintf("%.4f", sd(cor_series, na.rm=TRUE)), "\n")
} else {
  cat("\n*** DCC-GARCH model fitting failed for Cobalt ***\n")
  cat("REASON: Computational singularity due to near-perfect correlation between series\n")
  cat("RECOMMENDATION: Cobalt price series are too highly correlated for multivariate GARCH\n")
  cat("Skipping visualizations.\n\n")
}

cat("\n=== COBALT DCC-GARCH SECTION COMPLETE ===\n")
```

```{r dcc-copper, fig.width=12, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("                   COPPER - DCC-GARCH ANALYSIS\n")
cat("================================================================================\n\n")

# Limit to first 4 series for computational efficiency
max_series <- min(4, ncol(copper_xts))
copper_subset <- copper_xts[, 1:max_series]

cat("Using", max_series, "series for DCC-GARCH analysis:\n")
cat(paste("  -", colnames(copper_subset), collapse="\n"), "\n\n")

cat("Fitting DCC-GARCH(1,1) with Student-t distribution...\n")

copper_dcc <- tryCatch({
  library(rmgarch)
  
  garch_spec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                           variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
                           distribution.model = "std")
  multi_spec <- multispec(replicate(max_series, garch_spec))
  dcc_spec <- dccspec(uspec = multi_spec, dccOrder = c(1,1), distribution = "mvt")
  
  cat("  Fitting univariate GARCH models...\n")
  dcc_fit <- dccfit(dcc_spec, data = copper_subset, fit.control = list(eval.se=FALSE))
  
  cat("  ✓ Model fitted successfully!\n\n")
  dcc_fit
}, error = function(e) {
  cat("  ✗ Error:", e$message, "\n\n")
  return(NULL)
})

if(!is.null(copper_dcc)) {
  cat("\n=== COPPER DCC-GARCH RESULTS ===\n\n")
  
  dcc_params <- coef(copper_dcc, type="dcc")
  cat("DCC Parameters:\n")
  print(dcc_params)
  cat("\n")
  
  cat("Model Information Criteria:\n")
  cat("  Log-Likelihood:", sprintf("%.2f", likelihood(copper_dcc)), "\n")
  cat("  AIC:", sprintf("%.2f", infocriteria(copper_dcc)[1]), "\n")
  cat("  BIC:", sprintf("%.2f", infocriteria(copper_dcc)[2]), "\n\n")
  
  cat("\n=== COPPER DCC-GARCH VISUALIZATIONS ===\n\n")
  
  dcc_cor <- rcor(copper_dcc)
  n_series <- dim(dcc_cor)[2]
  
  par(mfrow=c(2,2), mar=c(4,4,3,2))
  plot_count <- 0
  for(i in 1:(n_series-1)) {
    for(j in (i+1):n_series) {
      if(plot_count < 4) {
        cor_series <- dcc_cor[i,j,]
        plot(as.Date(names(cor_series)), cor_series, type="l",
             main=paste("DCC:", colnames(copper_subset)[i], "-", colnames(copper_subset)[j]),
             xlab="Date", ylab="Correlation", col="brown", lwd=2)
        abline(h=mean(cor_series, na.rm=TRUE), col="red", lty=2, lwd=2)
        grid()
        plot_count <- plot_count + 1
      }
    }
  }
  par(mfrow=c(1,1))
  
  avg_corr_matrix <- matrix(0, nrow=n_series, ncol=n_series)
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      avg_corr_matrix[i,j] <- mean(dcc_cor[i,j,], na.rm=TRUE)
    }
  }
  rownames(avg_corr_matrix) <- colnames(avg_corr_matrix) <- colnames(copper_subset)
  
  par(mar=c(8,8,4,4))
  image(1:n_series, 1:n_series, avg_corr_matrix,
        col=colorRampPalette(c("blue", "white", "red"))(100),
        xlab="", ylab="", main="Copper: Average Dynamic Correlations",
        axes=FALSE, zlim=c(-1,1))
  axis(1, at=1:n_series, labels=colnames(copper_subset), las=2, cex.axis=0.8)
  axis(2, at=1:n_series, labels=colnames(copper_subset), las=2, cex.axis=0.8)
  
  for(i in 1:n_series) {
    for(j in 1:n_series) {
      text(i, j, sprintf("%.2f", avg_corr_matrix[i,j]), cex=0.8)
    }
  }
  par(mar=c(5,4,4,2))
} else {
  cat("\n*** DCC-GARCH model fitting failed for Copper ***\n")
  cat("Skipping visualizations.\n\n")
}

cat("\n=== COPPER DCC-GARCH SECTION COMPLETE ===\n")
```

```{r dcc-comparison, fig.width=14, fig.height=10}
cat("\n")
cat("================================================================================\n")
cat("           CROSS-METAL DCC-GARCH COMPARISON\n")
cat("================================================================================\n\n")

# Extract information from fitted models (handling NULL cases)
get_model_info <- function(dcc_fit, metal_name) {
  if(is.null(dcc_fit)) {
    return(list(aic = NA, bic = NA, loglik = NA))
  }
  info <- infocriteria(dcc_fit)
  return(list(
    aic = info[1],
    bic = info[2],
    loglik = likelihood(dcc_fit)
  ))
}

lithium_info <- get_model_info(lithium_dcc, "Lithium")
nickel_info <- get_model_info(nickel_dcc, "Nickel")
cobalt_info <- get_model_info(cobalt_dcc, "Cobalt")
copper_info <- get_model_info(copper_dcc, "Copper")

# Create comparison summary table
comparison_summary <- data.frame(
  Metal = c("Lithium", "Nickel", "Cobalt", "Copper"),
  N_Series_Total = c(ncol(lithium_xts), ncol(nickel_xts), ncol(cobalt_xts), ncol(copper_xts)),
  N_Series_Used = c(
    ifelse(is.null(lithium_dcc), 0, min(4, ncol(lithium_xts))),
    ifelse(is.null(nickel_dcc), 0, min(4, ncol(nickel_xts))),
    ifelse(is.null(cobalt_dcc), 0, min(4, ncol(cobalt_xts))),
    ifelse(is.null(copper_dcc), 0, min(4, ncol(copper_xts)))
  ),
  GARCH_Type = rep("sGARCH(1,1)", 4),
  Distribution = rep("Student-t", 4),
  LogLik = c(lithium_info$loglik, nickel_info$loglik, cobalt_info$loglik, copper_info$loglik),
  AIC = c(lithium_info$aic, nickel_info$aic, cobalt_info$aic, copper_info$aic),
  BIC = c(lithium_info$bic, nickel_info$bic, cobalt_info$bic, copper_info$bic),
  Status = c(
    ifelse(is.null(lithium_dcc), "Failed", "Fitted"),
    ifelse(is.null(nickel_dcc), "Failed", "Fitted"),
    ifelse(is.null(cobalt_dcc), "Failed", "Fitted"),
    ifelse(is.null(copper_dcc), "Failed", "Fitted")
  )
)

cat("=== DCC-GARCH MODEL COMPARISON ACROSS METALS ===\n\n")
kable(comparison_summary, digits=2,
      caption="Comparison of DCC-GARCH Models Across Metals")

cat("\n")
# Print summary of fitted vs failed models
n_fitted <- sum(comparison_summary$Status == "Fitted")
n_failed <- sum(comparison_summary$Status == "Failed")
cat("Models fitted successfully:", n_fitted, "of 4\n")
if(n_failed > 0) {
  failed_list <- comparison_summary$Metal[comparison_summary$Status == "Failed"]
  cat("Models that failed:", paste(failed_list, collapse=", "), "\n")
}
cat("\n")

# Visual comparison - show ALL metals, with failed ones in gray
par(mfrow=c(2,2), mar=c(6,5,3,2))

# Color vector: use color if fitted, gray if failed
bar_colors <- ifelse(comparison_summary$Status == "Fitted",
                     c("#E69F00", "#56B4E9", "#009E73", "#F0E442"),
                     "lightgray")

# 1. Number of series used
values1 <- ifelse(comparison_summary$Status == "Fitted", 
                  comparison_summary$N_Series_Used, 
                  0)
barplot(values1, names.arg=comparison_summary$Metal,
        col=bar_colors,
        main="Number of Series Used in DCC-GARCH",
        ylab="Count", border=NA, las=1)
# Add labels for fitted models
for(i in 1:4) {
  if(comparison_summary$Status[i] == "Fitted") {
    text(x=(i-1)*1.2 + 0.7, y=values1[i] + 0.2,
         labels=values1[i], cex=1.2, font=2)
  } else {
    text(x=(i-1)*1.2 + 0.7, y=0.5, labels="FAILED", cex=0.8, col="red", font=2)
  }
}

# 2. Log-Likelihood comparison
values2 <- comparison_summary$LogLik
values2[is.na(values2)] <- 0  # Set NA to 0 for plotting
barplot(values2, names.arg=comparison_summary$Metal,
        col=bar_colors,
        main="Log-Likelihood (Higher is Better)",
        ylab="Log-Likelihood", border=NA, las=1)
for(i in 1:4) {
  if(comparison_summary$Status[i] == "Failed") {
    text(x=(i-1)*1.2 + 0.7, y=min(values2[!is.na(comparison_summary$LogLik)])/2, 
         labels="FAILED", cex=0.8, col="red", font=2)
  }
}

# 3. AIC comparison
values3 <- comparison_summary$AIC
values3[is.na(values3)] <- 0
barplot(values3, names.arg=comparison_summary$Metal,
        col=bar_colors,
        main="AIC Comparison (Lower is Better)",
        ylab="AIC", border=NA, las=1)
for(i in 1:4) {
  if(comparison_summary$Status[i] == "Failed") {
    text(x=(i-1)*1.2 + 0.7, y=min(values3[!is.na(comparison_summary$AIC)])/2,
         labels="FAILED", cex=0.8, col="red", font=2)
  }
}

# 4. BIC comparison
values4 <- comparison_summary$BIC
values4[is.na(values4)] <- 0
barplot(values4, names.arg=comparison_summary$Metal,
        col=bar_colors,
        main="BIC Comparison (Lower is Better)",
        ylab="BIC", border=NA, las=1)
for(i in 1:4) {
  if(comparison_summary$Status[i] == "Failed") {
    text(x=(i-1)*1.2 + 0.7, y=min(values4[!is.na(comparison_summary$BIC)])/2,
         labels="FAILED", cex=0.8, col="red", font=2)
  }
}

par(mfrow=c(1,1))

cat("\n\n=== MODEL SPECIFICATION ===\n")
cat("All metals fitted with:\n")
cat("  - Model: DCC-GARCH(1,1) with sGARCH univariate specifications\n")
cat("  - Distribution: Multivariate Student-t\n")
cat("  - Series: Limited to first 4 series per metal for computational efficiency\n\n")

cat("=== INTERPRETATION ===\n")
cat("GARCH Type: Standard GARCH(1,1) - captures volatility clustering\n")
cat("Distribution: Student-t - allows for heavy tails common in financial data\n")
cat("AIC/BIC: Information criteria for model comparison (lower = better fit)\n")
cat("DCC: Dynamic conditional correlations capture time-varying relationships\n\n")

cat("================================================================================\n")
cat("                 DCC-GARCH ANALYSIS COMPLETE\n")
cat("================================================================================\n\n")
``` 